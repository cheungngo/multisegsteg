% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tests.R
\name{segsteg.test}
\alias{segsteg.test}
\title{Change Point Test for Regression Models}
\usage{
segsteg.test(
  formula.null,
  formula.chngpt,
  family = c("binomial", "gaussian"),
  data,
  type = c("step", "hinge", "segmented", "stegmented"),
  test.statistic = c("lr", "score"),
  chngpts = NULL,
  lb.quantile = 0.1,
  ub.quantile = 0.9,
  chngpts.cnt = 50,
  prec.weights = NULL,
  p.val.method = c("MC", "param.boot"),
  mc.n = 50000,
  boot.B = 10000,
  robust = FALSE,
  keep.fits = FALSE,
  verbose = FALSE,
  n_thresholds = 1,
  cluster_var = NULL
)
}
\arguments{
\item{formula.null}{Formula for the null model (without change points). When \code{n_thresholds = 1} and
\code{cluster_var} is specified (e.g., \code{cluster_var = "cluster"}), consider excluding \code{factor(ID)} from
the formula to avoid collinearity if \code{cluster} corresponds to \code{ID}. See Details for guidance.}

\item{formula.chngpt}{Formula specifying the change point variable.}

\item{family}{Family of the response variable ("binomial" or "gaussian").}

\item{data}{Data frame containing the variables.}

\item{type}{Type of change point model ("step", "hinge", "segmented", "stegmented").}

\item{test.statistic}{Test statistic for single threshold ("lr" or "score").}

\item{chngpts}{Optional vector of candidate thresholds.}

\item{lb.quantile}{Lower quantile for generating candidate thresholds.}

\item{ub.quantile}{Upper quantile for generating candidate thresholds.}

\item{chngpts.cnt}{Number of candidate thresholds to generate.}

\item{prec.weights}{Optional precision weights.}

\item{p.val.method}{Method for p-value calculation ("MC" or "param.boot").}

\item{mc.n}{Number of Monte Carlo simulations.}

\item{boot.B}{Number of bootstrap iterations.}

\item{robust}{Use robust standard errors.}

\item{keep.fits}{Keep model fits in the output.}

\item{verbose}{Print verbose output.}

\item{n_thresholds}{Number of thresholds to test.}

\item{cluster_var}{Optional cluster variable for robust standard errors (e.g., \code{"cluster"}). If used,
review the null model to avoid redundancy with \code{factor(ID)}.}
}
\value{
For \code{n_thresholds = 1}, a list of class "chngpt.test" containing:
\itemize{
\item \code{chngpt}: Estimated change point.
\item \code{statistic}: Test statistic.
\item \code{p.value}: P-value.
\item \code{loglik}: Log-likelihood of the alternative model.
\item \code{fit.null}: Null model fit (if \code{keep.fits = TRUE}).
\item \code{fit.alt}: Alternative model fit (if \code{keep.fits = TRUE}).
}

For \code{n_thresholds > 1}, a list of class "multi.segsteg.test" containing:
\itemize{
\item \code{thresholds}: Estimated thresholds.
\item \code{fit}: Final model fit with \code{n_thresholds} thresholds.
\item \code{loglik}: Log-likelihood of the final model.
\item \code{all_logliks}: Log-likelihoods for models with 0 to \code{n_thresholds} thresholds.
\item \code{p_values}: Sequential LRT p-values for each additional threshold.
}
}
\description{
Performs a test for change points in regression models, supporting single or multiple thresholds.
For multiple thresholds, it uses a sequential likelihood ratio test (LRT) to assess the significance
of adding each additional threshold. P-values are calculated using the chi-squared distribution
based on the LRT statistic.
}
\details{
For single thresholds (\code{n_thresholds = 1}), the function tests for a change point using likelihood
ratio or score tests, with p-values computed via Monte Carlo or parametric bootstrap methods. For
multiple thresholds (\code{n_thresholds > 1}), it supports "hinge" and "stegmented" types, using a
sequential LRT approach:
\enumerate{
\item Fits a null model (0 thresholds).
\item Fits models with 1 to \code{n_thresholds} thresholds, selecting the best combination.
\item Computes LRT statistic: \verb{2 * (loglik_k - loglik_\{k-1\})}.
\item Uses chi-squared distribution for p-values (df = 1 for "hinge", 2 for "stegmented").
}
\subsection{Consideration for \code{n_thresholds = 1}}{

When \code{n_thresholds = 1} and you specify \code{cluster_var = "cluster"} for cluster-robust standard errors,
including \code{factor(ID)} as fixed effects in \code{formula.null} might be redundant if \code{cluster} corresponds
to \code{ID}. This can lead to collinearity, causing a singular matrix error. To address this, try simplifying
the null model by removing \code{factor(ID)}:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{formula.null = as.formula('cholestrol ~ age + Gender + education + dose.METFORMIN + dose.ATORVASTATIN + dose.SIMVASTATIN')
}\if{html}{\out{</div>}}
\itemize{
\item \strong{Pros}: Reduces the number of parameters, likely eliminating singularity and improving model stability.
\item \strong{Cons}: Loses individual-specific intercepts, but clustering via \code{cluster_var} adjusts standard errors
for intra-ID correlation, mitigating this loss.
\item \strong{Test}: Rerun \code{segsteg.test} with the simplified formula. If it runs successfully, the issue was likely
due to \code{factor(ID)}.
}

This adjustment leverages \code{cluster_var} to handle ID-level effects implicitly, avoiding redundancy and
ensuring the model is well-specified.
}
}
\examples{
# Generate sample data with two hinge thresholds
set.seed(123)
n <- 100
x <- runif(n, 0, 10)
z <- rnorm(n)
true_thresholds <- c(3, 7)
y <- 2 + 0.5 * z + 1 * (x > true_thresholds[1]) * (x - true_thresholds[1]) +
     1.5 * (x > true_thresholds[2]) * (x - true_thresholds[2]) + rnorm(n)
data <- data.frame(y = y, x = x, z = z)

# Define formulas
formula.null <- y ~ z
formula.chngpt <- ~ x

# Test for two thresholds
result_multi <- segsteg.test(
  formula.null = formula.null,
  formula.chngpt = formula.chngpt,
  family = "gaussian",
  data = data,
  type = "hinge",
  n_thresholds = 2,
  lb.quantile = 0.1,
  ub.quantile = 0.9,
  chngpts.cnt = 20,
  verbose = TRUE
)

# Print results
print(result_multi$thresholds)  # Estimated thresholds
print(result_multi$p_values)    # P-values for each step

}
