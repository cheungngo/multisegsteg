% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tests.R
\name{multi_ss.test}
\alias{multi_ss.test}
\title{Change Point Test for Regression Models}
\usage{
multi_ss.test(
  formula.null,
  formula.chngpt,
  family = c("binomial", "gaussian"),
  data,
  type = c("step", "hinge", "segmented", "stegmented"),
  test.statistic = c("lr", "score"),
  chngpts = NULL,
  lb.quantile = 0.1,
  ub.quantile = 0.9,
  chngpts.cnt = 50,
  prec.weights = NULL,
  p.val.method = c("MC", "param.boot"),
  mc.n = 50000,
  boot.B = 10000,
  robust = FALSE,
  keep.fits = FALSE,
  verbose = FALSE,
  n_thresholds = 1,
  cluster_var = NULL
)
}
\arguments{
\item{formula.null}{Formula specifying the null model without change points. Note: When using
\code{n_thresholds = 1} with \code{cluster_var}, consider excluding redundant fixed effects to avoid
collinearity issues (see Details).}

\item{formula.chngpt}{Formula identifying the change point variable to be tested.}

\item{family}{Distribution family for response variable: "binomial" or "gaussian".}

\item{data}{Data frame containing all variables in the model.}

\item{type}{Change point model specification: "step", "hinge", "segmented", or "stegmented".}

\item{test.statistic}{Test statistic for single threshold testing: "lr" (likelihood ratio) or "score".}

\item{chngpts}{Optional vector of pre-specified candidate thresholds. If NULL, thresholds are
automatically generated.}

\item{lb.quantile}{Lower quantile bound for threshold generation (default: 0.1).}

\item{ub.quantile}{Upper quantile bound for threshold generation (default: 0.9).}

\item{chngpts.cnt}{Number of candidate thresholds to generate (default: 50).}

\item{prec.weights}{Optional precision weights for observations.}

\item{p.val.method}{Method for p-value calculation: "MC" (Monte Carlo) or "param.boot" (parametric bootstrap).}

\item{mc.n}{Number of Monte Carlo simulations for p-value calculation.}

\item{boot.B}{Number of bootstrap iterations for parametric bootstrap.}

\item{robust}{Logical; use robust standard error estimation if TRUE.}

\item{keep.fits}{Logical; retain model fits in output if TRUE.}

\item{verbose}{Logical; print detailed progress information if TRUE.}

\item{n_thresholds}{Number of thresholds to test (1 for single threshold test, >1 for multiple thresholds).}

\item{cluster_var}{Optional column name in data for cluster-robust standard errors (e.g., "subject_id").}
}
\value{
For single threshold testing (\code{n_thresholds = 1}), returns a list of class "chngpt.test" with elements:
\itemize{
\item \code{chngpt}: Estimated threshold location
\item \code{statistic}: Test statistic value
\item \code{p.value}: P-value for significance of the detected threshold
\item \code{loglik}: Log-likelihood of the alternative model
\item \code{fit.null}: Null model fit (if \code{keep.fits = TRUE})
\item \code{fit.alt}: Alternative model fit (if \code{keep.fits = TRUE})
\item \code{vcov_cluster}: Cluster-robust variance-covariance matrix (if \code{cluster_var} specified)
}

For multiple threshold testing (\code{n_thresholds > 1}), returns a list of class "multi.segsteg.test" with elements:
\itemize{
\item \code{thresholds}: Vector of estimated threshold locations
\item \code{fit}: Final fitted model with all thresholds
\item \code{loglik}: Log-likelihood of the final model
\item \code{all_logliks}: Vector of log-likelihoods for models with 0 to \code{n_thresholds} thresholds
\item \code{p_values}: Sequential LRT p-values for testing each additional threshold
\item \code{vcov_cluster}: Cluster-robust variance-covariance matrix (if \code{cluster_var} specified)
}
}
\description{
Performs statistical tests for detecting change points in regression models with support for
single or multiple thresholds. For multiple thresholds, implements a sequential likelihood
ratio test approach with p-values calculated using chi-squared distribution.
}
\details{
The function implements different approaches depending on the number of thresholds:
\subsection{Single Threshold Testing (\code{n_thresholds = 1})}{
\itemize{
\item Tests the null hypothesis of no change point against the alternative of one change point
\item Uses either likelihood ratio or score tests
\item P-values computed via Monte Carlo simulation or parametric bootstrap
\item Supports all change point types: "step", "hinge", "segmented", "stegmented"
}
}

\subsection{Multiple Threshold Testing (\code{n_thresholds > 1})}{
\itemize{
\item Currently supports only "hinge" and "stegmented" types
\item Implements sequential testing approach:
\enumerate{
\item Fits null model (0 thresholds)
\item Sequentially adds thresholds, selecting optimal locations at each step
\item Computes LRT statistic: 2 Ã— (loglik_k - loglik_{k-1})
\item Calculates p-values using chi-squared distribution (df = 1 for "hinge", df = 2 for "stegmented")
}
\item Automatically adjusts if insufficient unique thresholds are available
}
}

\subsection{Avoiding Collinearity with Clustering}{

When using \code{n_thresholds = 1} with cluster-robust standard errors (\code{cluster_var}), including
fixed effects like \code{factor(ID)} in the null model may cause collinearity if \code{cluster_var}
corresponds to the same grouping factor. To resolve this:
\enumerate{
\item Simplify the null model by removing the redundant fixed effects:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{formula.null = as.formula('outcome ~ covariates')  # Without factor(ID)
}\if{html}{\out{</div>}}
\item Use \code{cluster_var} to properly account for within-cluster correlation
}

This approach reduces the parameter count while maintaining appropriate standard error adjustment.
}
}
\examples{
# Generate sample data with two hinge thresholds
set.seed(123)
n <- 100
x <- runif(n, 0, 10)
z <- rnorm(n)
true_thresholds <- c(3, 7)
y <- 2 + 0.5 * z + 1 * (x > true_thresholds[1]) * (x - true_thresholds[1]) +
     1.5 * (x > true_thresholds[2]) * (x - true_thresholds[2]) + rnorm(n)
data <- data.frame(y = y, x = x, z = z)

# Test for two thresholds
result <- multi_ss.test(
  formula.null = y ~ z,
  formula.chngpt = ~ x,
  family = "gaussian",
  data = data,
  type = "hinge",
  n_thresholds = 2,
  lb.quantile = 0.1,
  ub.quantile = 0.9,
  chngpts.cnt = 20,
  verbose = TRUE
)

# Print results
print(result$thresholds)  # Estimated thresholds
print(result$p_values)    # Sequential p-values

}
